{"id": "meta-001", "type": "meta", "name": "Jeffrey Emanuel Site Improvements v0.3.0", "description": "Comprehensive enhancement plan for jeffreyemanuel.com based on visual analysis of the deployed site. These improvements transform a functional portfolio into a memorable, polished experience that reflects Jeffrey's technical excellence and attention to detail.", "created": "2024-12-15", "context": {"site_stack": "Next.js 16, React 19, Tailwind v4, Three.js, Framer Motion", "current_version": "v0.2.0", "target_version": "v0.3.0", "guiding_principles": ["Polish > Features - Every interaction should feel crafted", "Performance matters - No animation should cause jank", "Accessibility first - Enhancements must not exclude users", "Progressive enhancement - Core content always accessible", "Subtlety wins - Delight without distraction"]}}
{"id": "foundation-001", "type": "task", "name": "Performance Baseline", "category": "Foundation", "priority": "high", "effort": "S", "description": "Establish performance baseline before any changes. Run Lighthouse CI, measure Core Web Vitals (LCP, FID, CLS), document current bundle sizes. This gives us objective data to ensure improvements don't regress performance.", "depends_on": [], "acceptance_criteria": ["Lighthouse report saved for desktop and mobile", "Bundle size documented per route", "FCP, LCP, CLS, TBT recorded", "Baseline stored in /docs/performance-baseline.json"], "files": [], "notes": "Critical to do this FIRST. We're adding animations and effects which could hurt performance if not careful. Having a baseline lets us catch regressions early."}
{"id": "foundation-002", "type": "task", "name": "Component Architecture Audit", "category": "Foundation", "priority": "high", "effort": "M", "description": "Review current component structure to identify where enhancements should live. Map out: (1) Which components are client vs server, (2) Where motion/animation logic currently lives, (3) Shared hooks and utilities, (4) CSS architecture and design tokens. This prevents duplicated logic and ensures consistent implementation patterns.", "depends_on": [], "acceptance_criteria": ["Component tree documented", "Client/server boundary identified", "Shared utilities cataloged", "Motion patterns identified", "Design tokens extracted if needed"], "files": ["components/", "hooks/", "lib/"], "notes": "Understanding current architecture prevents creating parallel systems. We want to extend existing patterns, not fight them."}
{"id": "visual-001", "type": "task", "name": "Animated Stats Counter", "category": "Visual Polish", "priority": "high", "effort": "M", "description": "The hero section shows impressive stats (30K+ stars, 10+ agents, etc.) but they appear static. Numbers should animate counting up when they enter the viewport, creating a sense of accomplishment and drawing attention. Use requestAnimationFrame for smooth animation, not setInterval.", "depends_on": ["foundation-002"], "acceptance_criteria": ["Stats animate from 0 to target value", "Animation triggers on scroll into view (not on page load)", "Easing feels natural (ease-out curve)", "Animation completes in 1.5-2 seconds", "Respects prefers-reduced-motion", "No layout shift during animation", "Works on mobile"], "files": ["components/hero-section.tsx", "hooks/use-count-animation.ts"], "implementation_notes": "Create a reusable useCountUp hook that takes target value, duration, and optional easing. Use Intersection Observer to trigger. Consider using spring physics from framer-motion for more organic feel.", "why": "Static numbers feel dead. Animated numbers create a micro-moment of delight and reinforce the impressive scale of Jeffrey's work."}
{"id": "visual-002", "type": "task", "name": "Enhanced Card Hover States", "category": "Visual Polish", "priority": "high", "effort": "M", "description": "Project and article cards have basic hover states but lack depth. Enhance with: (1) Subtle scale transform (1.02x), (2) Elevated shadow suggesting lift, (3) Border glow effect matching card's gradient, (4) Smooth transitions (200-300ms). Cards should feel like physical objects responding to interaction.", "depends_on": ["foundation-002"], "acceptance_criteria": ["Cards scale up slightly on hover", "Shadow deepens suggesting elevation", "Border/glow effect appears", "Transition is smooth, not jarring", "Works with keyboard focus too", "No layout shift affecting siblings", "Touch devices get alternative feedback"], "files": ["components/project-card.tsx", "components/article-card.tsx", "components/ui/glass-card.tsx"], "implementation_notes": "Use CSS transforms for scale (GPU accelerated). Box-shadow transition can be expensive - consider using pseudo-element for shadow to enable opacity transition instead. Test on glass-card base component to affect all cards consistently.", "why": "Hover states communicate interactivity and add tactile quality. They make the interface feel responsive and alive."}
{"id": "visual-003", "type": "task", "name": "Section Spacing and Visual Breathing Room", "category": "Visual Polish", "priority": "high", "effort": "M", "description": "Several sections feel cramped with content packed too tightly. Increase vertical rhythm between sections, add more padding around key elements, and ensure the eye has places to rest. Specific areas: (1) Space between hero and snapshot section, (2) Padding around flywheel preview, (3) Project cards grid gaps, (4) Timeline item spacing.", "depends_on": ["foundation-002"], "acceptance_criteria": ["Section gaps increased to 6rem+ on desktop", "Consistent vertical rhythm established", "No section feels cramped", "Visual hierarchy clearer with spacing", "Responsive adjustments for mobile", "Screenshots show improved breathing room"], "files": ["app/page.tsx", "app/projects/page.tsx", "components/sections/"], "implementation_notes": "Create spacing scale in design tokens if not exists. Consider section wrapper component that enforces consistent spacing. Test with real content at various screen sizes.", "why": "White space is not empty space - it's a design element. Proper spacing improves readability, creates focus, and signals quality."}
{"id": "visual-004", "type": "task", "name": "Scroll-Triggered Section Animations", "category": "Visual Polish", "priority": "medium", "effort": "L", "description": "Content currently appears statically. Add subtle entrance animations as sections scroll into view: fade-up for text blocks, stagger for lists/grids, scale for images. Animations should be quick (300-500ms) and subtle - the content is the star, not the animation.", "depends_on": ["foundation-002", "visual-003"], "acceptance_criteria": ["Sections animate on first scroll into view", "Animation is subtle (20-30px translate, opacity)", "Grid items stagger with 50-100ms delay", "No animation replay on scroll back", "Respects prefers-reduced-motion", "No jank on mid-range devices", "SSR compatible (no flash)"], "files": ["hooks/use-scroll-animation.ts", "components/animated-section.tsx"], "implementation_notes": "Use Framer Motion's whileInView with viewport options. Consider intersection observer threshold of 0.2-0.3 to trigger before fully visible. Cache 'has animated' state to prevent replay. Test with throttled CPU.", "why": "Scroll animations add narrative flow to the page. They guide attention and create a sense of progression without being distracting."}
{"id": "visual-005", "type": "task", "name": "Micro-Interactions Polish", "category": "Visual Polish", "priority": "medium", "effort": "M", "description": "Add subtle feedback to all interactive elements: (1) Buttons get slight scale on press (0.98x), (2) Links get underline animation, (3) Form inputs get focus ring animation, (4) Nav items get hover indicator. These tiny details accumulate to create a premium feel.", "depends_on": ["foundation-002"], "acceptance_criteria": ["All buttons have press feedback", "Nav links have animated hover state", "Focus states are visible and animated", "Transitions feel consistent (same easing/duration)", "No interaction feels 'dead'", "Works on touch devices"], "files": ["components/ui/button.tsx", "components/site-header.tsx", "components/ui/input.tsx", "app/globals.css"], "implementation_notes": "Create shared transition constants (duration, easing). Use :active for press states. Consider CSS custom properties for animation values. Test keyboard navigation thoroughly.", "why": "Micro-interactions are the difference between 'functional' and 'delightful'. They acknowledge user actions and make the interface feel responsive."}
{"id": "func-001", "type": "task", "name": "Live GitHub Stats API", "category": "Functionality", "priority": "medium", "effort": "L", "description": "Currently star counts are hardcoded and will become stale. Create a GitHub stats service that: (1) Fetches star counts for all repos, (2) Caches results for 1 hour, (3) Falls back to hardcoded values on error, (4) Updates at build time and optionally client-side. Show 'last updated' timestamp.", "depends_on": ["foundation-002"], "acceptance_criteria": ["Star counts fetch from GitHub API", "Results cached (ISR or edge cache)", "Graceful fallback on API failure", "Rate limiting handled (60/hr unauthenticated)", "Build doesn't fail if GitHub is down", "Optionally show 'updated X ago'"], "files": ["lib/github-stats.ts", "app/api/github-stats/route.ts", "lib/content.ts"], "implementation_notes": "Use GitHub's REST API v3 with unauthenticated requests (60/hr limit is fine for build-time). Consider using PAT for higher limits if needed. Store in Redis/KV for edge caching, or use Next.js ISR with 1hr revalidate. Must handle ECONNRESET and timeout gracefully.", "why": "Fresh data builds credibility. Stale '2,790 stars' that's actually 3,500 undermines trust. Live stats also show the site is actively maintained."}
{"id": "func-002", "type": "task", "name": "Article Reading Time and Progress", "category": "Functionality", "priority": "medium", "effort": "M", "description": "Enhance article pages with: (1) Estimated reading time displayed near title, (2) Progress bar at top of page showing scroll position, (3) Optional floating 'back to top' button after 50% scroll. These UX patterns are expected on modern blogs.", "depends_on": ["foundation-002"], "acceptance_criteria": ["Reading time calculated from word count", "Reading time displayed (e.g., '8 min read')", "Progress bar shows scroll position", "Progress bar is thin and unobtrusive", "Back to top button appears after scroll", "Works with variable length articles", "SSR compatible"], "files": ["app/writing/[slug]/page.tsx", "components/article-progress.tsx", "components/back-to-top.tsx", "lib/reading-time.ts"], "implementation_notes": "Reading time: ~200-250 words per minute is standard. Progress bar: use scroll event with throttle, position fixed at top. Consider using CSS scroll-timeline for progress if browser support adequate. Back to top: use IntersectionObserver to show/hide.", "why": "Reading time sets expectations and helps users decide to commit. Progress bar provides orientation in long content. These are table-stakes for good reading UX."}
{"id": "func-003", "type": "task", "name": "Table of Contents for Long Articles", "category": "Functionality", "priority": "low", "effort": "M", "description": "For longer articles (>5 headings), generate an automatic table of contents. Options: (1) Sticky sidebar TOC on desktop, (2) Collapsible TOC at article start, (3) Floating TOC pill. TOC should highlight current section and allow click-to-scroll.", "depends_on": ["func-002"], "acceptance_criteria": ["TOC generated from H2/H3 headings", "Current section highlighted as you scroll", "Clicking scrolls smoothly to section", "TOC hidden for short articles", "Mobile: collapsible at top", "Desktop: sidebar or floating"], "files": ["app/writing/[slug]/page.tsx", "components/table-of-contents.tsx", "lib/toc-parser.ts"], "implementation_notes": "Parse MDX/HTML for heading elements. Generate slugs for IDs if not present. Use IntersectionObserver for current section detection. Consider markdown-toc or remark plugin for build-time generation.", "why": "Long-form content benefits from navigation aids. TOC improves scannability and helps readers find specific sections."}
{"id": "func-004", "type": "task", "name": "Command Palette Search (Cmd+K)", "category": "Functionality", "priority": "medium", "effort": "XL", "description": "Implement a command palette (Cmd+K / Ctrl+K) for power users. Features: (1) Search all pages and articles, (2) Quick navigation to sections, (3) Keyboard-navigable results, (4) Recent searches, (5) Fuzzy matching. This is a signature feature that signals technical sophistication.", "depends_on": ["foundation-002"], "acceptance_criteria": ["Cmd+K opens palette modal", "Search indexes all content", "Results show page title + snippet", "Arrow keys navigate results", "Enter navigates to selection", "Escape closes palette", "Recent/frequent items shown", "Fuzzy search works", "Accessible (focus trap, announcements)"], "files": ["components/command-palette.tsx", "hooks/use-search.ts", "lib/search-index.ts", "app/api/search/route.ts"], "implementation_notes": "Consider using cmdk library (pacocoursey/cmdk) for the UI - it handles a11y well. For search: build static index at build time, use fuse.js or minisearch for client-side fuzzy search. Index: page titles, descriptions, article content, headings. Keep index under 50KB for performance.", "why": "Command palettes are beloved by developers. They show attention to power users and create a memorable 'aha' moment. Also genuinely useful for navigation."}
{"id": "func-005", "type": "task", "name": "Mobile 3D Fallback", "category": "Functionality", "priority": "high", "effort": "M", "description": "The Three.js flywheel visualization is impressive but: (1) May drain mobile batteries, (2) Can be janky on low-end devices, (3) Takes time to load. Create a beautiful static fallback for mobile: high-quality rendered image or simplified SVG animation that captures the essence without the overhead.", "depends_on": ["foundation-002"], "acceptance_criteria": ["Mobile devices get static/lightweight fallback", "Fallback is visually cohesive with full version", "Fallback loads faster than 3D", "User can opt-in to 3D on mobile if desired", "Breakpoint is appropriate (likely <768px)", "No flash/layout shift during switch"], "files": ["components/flywheel-visualization.tsx", "components/flywheel-static.tsx", "public/images/flywheel-preview.webp"], "implementation_notes": "Render a high-quality frame from the 3D version to use as static image. Consider using CSS/SVG animation for subtle motion (rotating glow, pulsing dots). Use matchMedia or Tailwind responsive to switch. Lazy load the full 3D bundle only on desktop.", "why": "Performance is a feature. Mobile users shouldn't suffer for a visual flourish. The fallback should feel intentional, not like a degraded experience."}
{"id": "flywheel-001", "type": "task", "name": "Flywheel Particle Effects", "category": "Flywheel Enhancement", "priority": "low", "effort": "L", "description": "Add subtle particle effects to the flywheel visualization: (1) Small particles flowing along connection lines, (2) Sparkle effect on hover over tools, (3) Energy pulse when tool is selected. These effects should enhance the 'living system' feel without being distracting.", "depends_on": ["foundation-002", "func-005"], "acceptance_criteria": ["Particles flow along connection lines", "Hover creates sparkle/glow effect", "Selection triggers energy pulse", "Effects are subtle and performant", "Can be disabled for performance", "Respects prefers-reduced-motion"], "files": ["components/flywheel-visualization.tsx", "components/flywheel-particles.tsx"], "implementation_notes": "Use Three.js Points or InstancedMesh for particles. Keep particle count low (<100). Consider using shader for particle animation. Test on mid-range devices. Add quality setting toggle.", "why": "The flywheel represents a dynamic, interconnected system. Particle effects reinforce this metaphor and add visual interest to an already impressive visualization."}
{"id": "flywheel-002", "type": "task", "name": "Flywheel Tool Selection Highlights", "category": "Flywheel Enhancement", "priority": "medium", "effort": "M", "description": "When a tool in the flywheel is selected: (1) Connected tools should subtly highlight, (2) Connection lines should glow, (3) Unrelated tools should dim slightly, (4) Selection should feel impactful. This helps users understand the interconnected nature of the tools.", "depends_on": ["foundation-002"], "acceptance_criteria": ["Selected tool is clearly highlighted", "Connected tools get secondary highlight", "Connections to selected tool glow", "Unselected tools dim (not disappear)", "Transitions are smooth (300ms)", "Works with keyboard selection too"], "files": ["components/flywheel-visualization.tsx", "components/projects-page.tsx"], "implementation_notes": "Track selected tool ID in state. Use Three.js material properties to adjust opacity/emissive. For connections, could use LineBasicMaterial color or custom shader. Consider bloom post-processing for glow effect.", "why": "Selection feedback makes the visualization more informative. It visually demonstrates how the tools relate to each other, reinforcing the 'flywheel' concept."}
{"id": "a11y-001", "type": "task", "name": "Enhanced Focus States", "category": "Accessibility", "priority": "high", "effort": "M", "description": "Ensure all interactive elements have clear, visible focus states that meet WCAG 2.1 AA. Current focus states may be too subtle or missing. Focus should be obvious but not ugly - consider using outline-offset and color that complements the design.", "depends_on": ["foundation-002"], "acceptance_criteria": ["All interactive elements have visible focus", "Focus contrast meets WCAG 2.1 AA (3:1)", "Focus style is consistent across site", "Focus is visible in both light areas and dark", "Tab order is logical", "No focus traps except modals"], "files": ["app/globals.css", "components/ui/"], "implementation_notes": "Use CSS :focus-visible to show focus only for keyboard. Consider outline: 2px solid with outline-offset: 2px. Test with high contrast mode. Use browser dev tools accessibility panel to verify.", "why": "Keyboard users must be able to see where they are. Good focus states benefit everyone and are legally required for accessibility compliance."}
{"id": "a11y-002", "type": "task", "name": "Reduced Motion Support", "category": "Accessibility", "priority": "high", "effort": "M", "description": "Respect prefers-reduced-motion media query throughout the site. Users with vestibular disorders can be made physically ill by animations. When reduced motion is preferred: (1) Disable scroll animations, (2) Instant transitions instead of animated, (3) Disable 3D effects, (4) Keep essential feedback.", "depends_on": ["visual-004", "visual-005"], "acceptance_criteria": ["All animations check prefers-reduced-motion", "Alternative non-animated states exist", "Essential feedback preserved (hover states ok)", "No jarring content shifts", "Testing with reduced motion enabled passes", "Framer Motion reducedMotion prop used"], "files": ["hooks/use-reduced-motion.ts", "components/animated-section.tsx", "tailwind.config.ts"], "implementation_notes": "Create useReducedMotion hook. Framer Motion has built-in support via ReducedMotion component or reducedMotion prop. For CSS, use @media (prefers-reduced-motion: reduce). Keep color/opacity changes as they don't cause vestibular issues.", "why": "This is an accessibility requirement, not a nice-to-have. Some users literally cannot use sites with excessive motion. Respecting this preference is ethical and inclusive."}
{"id": "a11y-003", "type": "task", "name": "Keyboard Navigation Audit", "category": "Accessibility", "priority": "medium", "effort": "M", "description": "Comprehensive keyboard navigation testing and fixes. Ensure: (1) All interactive elements reachable via Tab, (2) Logical tab order, (3) Arrow key navigation in lists/grids, (4) Escape closes modals, (5) Enter/Space activate buttons, (6) Custom widgets have proper keyboard support.", "depends_on": ["a11y-001", "func-004"], "acceptance_criteria": ["Full site navigable by keyboard", "Tab order matches visual order", "No keyboard traps", "Custom widgets (flywheel, palette) keyboard accessible", "Skip link works", "Focus management in SPA navigation"], "files": ["components/"], "implementation_notes": "Tab through entire site manually. Check flywheel tool selection with keyboard. Test command palette keyboard nav. Use tabindex carefully - prefer natural order. Add aria-label where needed.", "why": "Keyboard navigation is essential for users who can't use a mouse. This includes people with motor disabilities, power users, and users of assistive technology."}
{"id": "perf-001", "type": "task", "name": "Image Optimization Audit", "category": "Performance", "priority": "medium", "effort": "M", "description": "Audit all images for optimization: (1) Use Next.js Image component everywhere, (2) Proper sizing (no 4K images in thumbnails), (3) Modern formats (WebP/AVIF), (4) Lazy loading below fold, (5) Blur placeholders. Images are often the biggest performance culprit.", "depends_on": ["foundation-001"], "acceptance_criteria": ["All images use next/image", "Proper width/height specified", "WebP with JPEG fallback", "Lazy loading for below-fold images", "Blur placeholder for LCP images", "No images larger than needed"], "files": ["components/", "app/", "public/images/"], "implementation_notes": "Run Lighthouse image audit. Check for img tags not using Next Image. Verify sizes prop is used correctly. Consider blur data URLs for hero images. Check remote images are optimized.", "why": "Images are usually the largest assets. Unoptimized images tank Core Web Vitals and frustrate users on slow connections."}
{"id": "perf-002", "type": "task", "name": "Bundle Size Analysis", "category": "Performance", "priority": "medium", "effort": "M", "description": "Analyze and optimize JavaScript bundle size. Key areas: (1) Three.js should be code-split, (2) Framer Motion tree-shaking, (3) No duplicate dependencies, (4) Route-based code splitting working, (5) Third-party script evaluation.", "depends_on": ["foundation-001"], "acceptance_criteria": ["Bundle analyzer report generated", "Three.js lazy loaded (not in main bundle)", "No duplicate dependencies", "Main bundle < 150KB gzipped", "Route bundles appropriately sized", "Critical path JS minimized"], "files": ["next.config.js", "package.json"], "implementation_notes": "Use @next/bundle-analyzer to visualize. Check for duplicate React, duplicate lodash methods, etc. Ensure dynamic imports work for Three.js. Consider using lighter alternatives if dependencies are heavy.", "why": "Large bundles slow initial load and hurt mobile users. JavaScript is the most expensive asset byte-for-byte."}
{"id": "perf-003", "type": "task", "name": "Core Web Vitals Optimization", "category": "Performance", "priority": "high", "effort": "L", "description": "Target green scores on all Core Web Vitals: LCP < 2.5s, FID < 100ms, CLS < 0.1. Specific optimizations: (1) Preload hero font, (2) Inline critical CSS, (3) Reserve space for dynamic content, (4) Optimize largest contentful paint element.", "depends_on": ["foundation-001", "perf-001", "perf-002"], "acceptance_criteria": ["LCP < 2.5s on mobile", "FID < 100ms", "CLS < 0.1", "Lighthouse Performance > 90", "No layout shift on load", "First paint fast"], "files": ["app/layout.tsx", "app/globals.css", "next.config.js"], "implementation_notes": "Use web-vitals library to measure real user metrics. Identify LCP element and optimize its load. Check for CLS sources with Layout Instability API. Preconnect to external domains. Consider using next/font.", "why": "Core Web Vitals affect SEO ranking and user experience. They're Google's official UX metrics and worth optimizing."}
{"id": "delight-001", "type": "task", "name": "Custom Cursor Effects", "category": "Delight", "priority": "low", "effort": "M", "description": "Add subtle custom cursor effects for desktop users: (1) Cursor grows slightly on interactive elements, (2) Cursor leaves subtle trail on the flywheel page, (3) Cursor changes on draggable elements. These should be very subtle and only for desktop.", "depends_on": ["foundation-002", "a11y-002"], "acceptance_criteria": ["Custom cursor on desktop only", "Cursor responds to element types", "Effect is subtle, not distracting", "No performance impact", "Disabled if reduced motion preferred", "Doesn't interfere with native cursor behavior"], "files": ["components/custom-cursor.tsx", "hooks/use-cursor.ts"], "implementation_notes": "Use CSS cursor for simple changes. For custom cursor element, track mouse with requestAnimationFrame. Keep cursor simple - don't recreate the OS cursor poorly. Consider blend mode for visibility.", "why": "Cursor effects are a subtle signature touch. They shouldn't dominate but add a layer of polish that distinguishes the site."}
{"id": "delight-002", "type": "task", "name": "Easter Eggs", "category": "Delight", "priority": "low", "effort": "S", "description": "Add hidden delights for explorers: (1) Konami code triggers something fun, (2) Console message for devs who inspect, (3) Hidden page or interaction discoverable through exploration. These reward curiosity without affecting normal users.", "depends_on": [], "acceptance_criteria": ["At least one discoverable easter egg", "Doesn't affect normal site operation", "Fun and on-brand", "Console has developer greeting", "Discoverable but not obvious"], "files": ["hooks/use-konami.ts", "app/layout.tsx"], "implementation_notes": "Konami: track key sequence, trigger when complete. Console: use console.log with styled message. Consider ASCII art. Hidden interactions could be clicking certain elements in sequence.", "why": "Easter eggs create memorable moments and show personality. They're beloved in developer culture and often get shared on social media."}
{"id": "delight-003", "type": "task", "name": "Ambient Sound Design (Optional)", "category": "Delight", "priority": "low", "effort": "M", "description": "OPTIONAL: Add subtle sound design that's OFF by default. Users can opt-in via toggle. Sounds: (1) Soft click on button press, (2) Whoosh on page transition, (3) Ambient hum on flywheel page. Sound should be very subtle and high quality.", "depends_on": ["foundation-002", "a11y-002"], "acceptance_criteria": ["Sounds are OFF by default", "Clear toggle to enable", "Sounds are subtle and pleasant", "Volume is appropriate", "No sound on mobile", "Respects system sound settings", "Files are small (<50KB total)"], "files": ["hooks/use-sound.ts", "components/sound-toggle.tsx", "public/sounds/"], "implementation_notes": "Use Web Audio API or howler.js. Sounds must be very short (<1s) and quiet. Consider using tone.js for synthesized sounds (smaller than audio files). Test on various speakers. This is genuinely optional - only if it enhances.", "why": "Sound design is often overlooked on the web. When done well, it creates immersion. When done poorly, it's annoying. Default OFF is critical."}
{"id": "content-001", "type": "task", "name": "Copy Polish Pass", "category": "Content", "priority": "medium", "effort": "M", "description": "Review all site copy for: (1) Consistency in voice, (2) Clarity and concision, (3) Technical accuracy, (4) Natural language (avoid AI-isms like em-dashes, 'It's not just X, it's Y'), (5) Compelling CTAs. The words matter as much as the design.", "depends_on": [], "acceptance_criteria": ["All copy reviewed", "Em-dashes removed or replaced naturally", "Voice is consistent throughout", "CTAs are compelling", "No AI-sounding phrases", "Technical claims accurate"], "files": ["lib/content.ts", "app/", "content/"], "notes": "Completed partial pass: fixed 4 em-dashes in lib/content.ts tool descriptions on 2024-12-15. Need full review of remaining content.", "why": "Copy is the voice of the site. AI-generated-sounding copy undermines credibility. Every word should feel intentionally chosen."}
{"id": "qa-001", "type": "task", "name": "Cross-Browser Testing", "category": "QA", "priority": "high", "effort": "M", "description": "Test all improvements across browsers: Chrome, Firefox, Safari, Edge. Pay special attention to: (1) Three.js/WebGL rendering, (2) CSS animations, (3) Backdrop blur support, (4) Grid layouts, (5) Font rendering.", "depends_on": ["visual-001", "visual-002", "visual-003", "visual-004", "visual-005"], "acceptance_criteria": ["Works in Chrome (latest 2 versions)", "Works in Firefox (latest 2 versions)", "Works in Safari (latest 2 versions)", "Works in Edge (latest 2 versions)", "Graceful degradation for older browsers", "No console errors"], "files": [], "implementation_notes": "Use BrowserStack or similar for Safari testing if no Mac. Check CSS @supports for backdrop-filter. Test WebGL support detection. Document any browser-specific issues.", "why": "Cross-browser compatibility ensures all visitors have a good experience. Safari in particular often has different behavior."}
{"id": "qa-002", "type": "task", "name": "Mobile Device Testing", "category": "QA", "priority": "high", "effort": "M", "description": "Test on real mobile devices: iOS Safari, Chrome Android. Test: (1) Touch interactions, (2) Scroll performance, (3) Font sizes, (4) Tap targets (min 44px), (5) Orientation changes, (6) PWA installation.", "depends_on": ["func-005", "visual-003"], "acceptance_criteria": ["iOS Safari works correctly", "Chrome Android works correctly", "Tap targets are 44px minimum", "Text is readable without zoom", "Orientation changes handled", "No janky scrolling", "Forms work with mobile keyboards"], "files": [], "implementation_notes": "Use real devices, not just Chrome DevTools. iOS Safari has unique quirks (100vh, scroll bounce, etc.). Test with slow 3G throttling. Check safe area insets for notched phones.", "why": "Mobile traffic is significant. Emulators miss real-world issues like touch responsiveness and actual performance."}
{"id": "qa-003", "type": "task", "name": "Playwright E2E Test Suite", "category": "QA", "priority": "medium", "effort": "L", "description": "Create Playwright test suite covering: (1) All pages load without error, (2) Navigation works, (3) Interactive elements function, (4) No console errors, (5) Visual regression tests for key pages. Tests should run in CI.", "depends_on": ["qa-001"], "acceptance_criteria": ["Tests for all page routes", "Tests for flywheel interaction", "Tests for command palette", "Visual regression tests", "Tests run in GitHub Actions", "< 2 minute test run time"], "files": ["tests/", "playwright.config.ts", ".github/workflows/"], "implementation_notes": "Use Playwright's built-in visual comparison. Focus on critical paths not every edge case. Run in CI on PR and main. Consider parallelization for speed.", "why": "E2E tests catch regressions before users do. Visual regression tests are especially valuable for a portfolio site where appearance matters."}
{"id": "release-001", "type": "task", "name": "v0.3.0 Release", "category": "Release", "priority": "high", "effort": "S", "description": "Prepare and execute v0.3.0 release: (1) Update version numbers, (2) Write changelog, (3) Tag release, (4) Deploy to production, (5) Verify deployment, (6) Update any documentation.", "depends_on": ["qa-001", "qa-002", "perf-003"], "acceptance_criteria": ["All planned improvements implemented", "Changelog documents all changes", "Git tag created", "Deployed to production", "Smoke tests pass on production", "Performance verified post-deploy"], "files": ["package.json", "CHANGELOG.md"], "why": "Clean releases with proper versioning and documentation make the project maintainable and demonstrate professional practices."}
{"id": "meta-002", "type": "dependency_summary", "name": "Task Dependency Overview", "description": "High-level dependency structure for implementation planning", "critical_path": ["foundation-001", "foundation-002", "visual-001", "visual-002", "visual-003", "a11y-001", "a11y-002", "perf-003", "qa-001", "qa-002", "release-001"], "parallel_tracks": {"visual_polish": ["visual-001", "visual-002", "visual-003", "visual-004", "visual-005"], "functionality": ["func-001", "func-002", "func-003", "func-004", "func-005"], "accessibility": ["a11y-001", "a11y-002", "a11y-003"], "performance": ["perf-001", "perf-002", "perf-003"], "delight": ["delight-001", "delight-002", "delight-003"]}, "implementation_order_suggestion": "Start with foundation tasks in parallel. Then tackle high-priority items from each track concurrently. Visual polish and accessibility should precede delight items. Performance optimization near end to measure actual impact. QA throughout, formal QA before release."}
